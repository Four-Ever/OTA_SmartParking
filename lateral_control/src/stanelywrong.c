/**********************************************************************************************************************
 * \file servo.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
#include <stanelywrong.h>
#include <stdio.h>
#include "math.h"

/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/

/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
VehicleState vehicle;

const float32 waypoints[NUM_WAYPOINTS][2] = {
    {0.0f, -3.0f},
    {2.0f, -2.5f},
    {4.0f, -2.0f},
    {5.25f, -1.5f},
    {6.5f, -1.0f},
    {7.5f, 0.0f},
    {7.0f, -1.2f},
    {6.5f, -2.0f},
    {6.0f, -2.8f},
    {5.5f, -3.5f},
    {5.0f, -4.0f},
    {4.5f, -4.4f},
    {4.0f, -4.7f},
    {3.5f, -4.9f},
    {3.0f, -5.0f},
    {2.0f, -5.0f}
};

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/


/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/

// 유틸리티 함수
static float32 wrapToPi(float32 angle) {
    while (angle > PI) angle -= 2.0f * PI;
    while (angle < -PI) angle += 2.0f * PI;
    return angle;
}

static float32 calculateDistance(float32 x1, float32 y1, float32 x2, float32 y2) {
    return sqrtf(powf(x2-x1, 2) + powf(y2-y1, 2));
}

// 초기화 함수
void initVehicle(void) {
    vehicle.x = waypoints[0][0];
    vehicle.y = waypoints[0][1];
    vehicle.theta = atan2f(waypoints[1][1] - vehicle.y,
                          waypoints[1][0] - vehicle.x);
    vehicle.v = 2.0f;
    vehicle.isReversing = FALSE;
    vehicle.currentWpIdx = 1;
    vehicle.prevSteeringAngle = 0.0f;
}

// Stanley 제어 알고리즘
float32 runStanleyControl(void) {
    float32 targetX = waypoints[vehicle.currentWpIdx][0];
    float32 targetY = waypoints[vehicle.currentWpIdx][1];

    // 현재 위치와 목표점 사이의 거리 계산
    float32 distance = calculateDistance(vehicle.x, vehicle.y, targetX, targetY);

    // Waypoint 도달 확인 및 업데이트
    if (distance < WAYPOINT_TOLERANCE) {
        if (vehicle.currentWpIdx < NUM_WAYPOINTS - 1) {
            vehicle.currentWpIdx++;
            if (vehicle.currentWpIdx >= REVERSE_START_IDX && !vehicle.isReversing) {
                vehicle.isReversing = TRUE;
                vehicle.theta = wrapToPi(vehicle.theta + PI);
                vehicle.v = -2.0f;
            }
        }
    }

    // Stanley 제어 계산
    float32 pathAngle = atan2f(targetY - vehicle.y, targetX - vehicle.x);
    float32 headingError = wrapToPi(pathAngle - vehicle.theta);
    float32 cte = sinf(headingError) * distance;

    float32 steeringAngle = atan2f(0.5f * cte, fabsf(vehicle.v)) - headingError;

    // 조향각 제한
    if (steeringAngle > MAX_STEER) steeringAngle = MAX_STEER;
    if (steeringAngle < -MAX_STEER) steeringAngle = -MAX_STEER;

    // 후진 시 조향각 반전
    if (vehicle.isReversing) {
        steeringAngle = -steeringAngle;
    }

    // 차량 상태 업데이트 (dt = 0.01f for 10ms task)
    vehicle.x += vehicle.v * cosf(vehicle.theta) * 0.01f;
    vehicle.y += vehicle.v * sinf(vehicle.theta) * 0.01f;
    vehicle.theta = wrapToPi(vehicle.theta - (vehicle.v / L) * tanf(steeringAngle) * 0.01f);

    return steeringAngle;
}
/*********************************************************************************************************************/
