///**********************************************************************************************************************
// * \file Cpu0_Main.c
// * \copyright Copyright (C) Infineon Technologies AG 2019
// *
// * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
// * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
// * are agreed, use of this file is subject to following:
// *
// * Boost Software License - Version 1.0 - August 17th, 2003
// *
// * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
// * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
// * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
// * Software is furnished to do so, all subject to the following:
// *
// * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
// * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
// * derivative works of the Software, unless such copies or derivative works are solely in the form of
// * machine-executable object code generated by a source language processor.
// *
// * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
// * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
// * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// * IN THE SOFTWARE.
// *********************************************************************************************************************/
//#include "Ifx_Types.h"
//#include "IfxCpu.h"
//#include "IfxScuWdt.h"
//#include "IfxPort.h"
//#include "IfxPort_PinMap.h"
//#include "IfxStm.h"
//#include "Ultra_Driver.h"
//#include "IMU_Driver.h"
//#include "ASCLIN_Shell_UART.h"
//IfxCpu_syncEvent g_cpuSyncEvent = 0;
//
//float nowdistance = 0;
//uint8 now = 0;
//IfxI2c_I2c_Status first = 4;
//IfxI2c_I2c_Status second = 4;
//IfxI2c_I2c_Status third = 4;
//IfxI2c_I2c_Status fourth = 4;
//IfxI2c_I2c_Status test1 = 4;
//IfxI2c_I2c_Status test2 = 4;
//IfxI2c_I2c_Status test3 = 4;
//IfxI2c_I2c_Status test4 = 4;
//IfxI2c_I2c_Status test5 = 4;
//IfxI2c_I2c_Status test6 = 4;
//IfxI2c_I2c_Status test7 = 4;
//IfxI2c_I2c_Status test8 = 4;
////////////////////////////////////
//IMU now_status={0,0,0,0,0,0,0,0,0,0};
//Euler now_euler = {0,0,0};
//uint8 in=0;
//uint8 now13 =0;
//// ak status check reg
//uint8 status1_val = 0;
//uint8 status2_val = 5;
//float asa_x = 0;
//float asa_y = 0;
//float asa_z = 0;
//int i=0;
//void core0_main (void)
//{
//    IfxCpu_enableInterrupts();
//    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
//    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
//
//    IfxCpu_emitEvent(&g_cpuSyncEvent);
//    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
//    /////////////////////////////////////////////////////
//    initIMU();
//    now13=1;
//    initShellInterface();
//    in =5;
////    uint32 startTime = MODULE_STM0.TIM0.U;
////    uint32 endTime = MODULE_STM0.TIM0.U;
////    uint32 samplingTime = 0;
//
//    while (1)
//    {
//        i++;
//        //now13=2;
//        delay(5000);//0.005
//        now_status=imuRead();
//        float temp = now_status.mag_x;
//        now_status.mag_x=now_status.mag_y;
//        now_status.mag_y=temp;
//        now_status.mag_x=-now_status.mag_x;
////        now_euler.roll =asa_x;
////        now_euler.pitch =asa_y;
////        now_euler.yaw =asa_z;
//
//
//        //now13=3;
//        if(i>2000)
//            now_euler=MadgwickAHRSupdate(now_status);
//            //now_euler = updateMadgwick(now_status);
//            print_enc(&now_status, &now_euler);
//        //if(i%100==0)checkoffset();
//
//    }
//}

/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "IfxPort.h"
#include "IfxPort_PinMap.h"
#include "Driver_Stm.h"
#include "Ultra_Driver.h"
#include "IMU_Driver.h"
#include "ASCLIN_Shell_UART.h"

typedef struct
{
    uint32 u32nuCnt1ms;
    uint32 u32nuCnt10ms;
    uint32 u32nuCnt100ms;
    uint32 u32nuCnt1000ms;
} TestCnt;

// Task scheduling related
void AppScheduling (void);
void AppTask1ms (void);
void AppTask10ms (void);
void AppTask100ms (void);
void AppTask1000ms (void);
/***********************************************************************/
/*Variable*/
/***********************************************************************/
TestCnt stTestCnt;

IfxCpu_syncEvent g_cpuSyncEvent = 0;

uint8 now = 0;
IfxI2c_I2c_Status first = 4;
IfxI2c_I2c_Status second = 4;
IfxI2c_I2c_Status third = 4;
IfxI2c_I2c_Status fourth = 4;
IfxI2c_I2c_Status test1 = 4;
IfxI2c_I2c_Status test2 = 4;
IfxI2c_I2c_Status test3 = 4;
IfxI2c_I2c_Status test4 = 4;
IfxI2c_I2c_Status test5 = 4;
IfxI2c_I2c_Status test6 = 4;
IfxI2c_I2c_Status test7 = 4;
IfxI2c_I2c_Status test8 = 4;
//////////////////////////////////
IMU now_status = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
Euler now_euler = {0, 0, 0};
uint8 in = 0;
uint8 now13 = 0;
// ak status check reg
uint8 status1_val = 0;
uint8 status2_val = 5;
float asa_x = 0;
float asa_y = 0;
float asa_z = 0;
int i = 0;
float scale_x =0.0f;
float scale_y=0.0f;
float scale_z=0.0f;
float x_offset=0.0f;
float y_offset=0.0f;
float z_offset=0.0f;
volatile float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;  // quaternion of sensor frame relative to auxiliary frame
int nowcnt=0;
void Touch(void);
void initGPIO(void);
IfxPort_State TouchState=0;
int stopstatus =0;
int core0_main (void)
{
    IfxCpu_enableInterrupts();

    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    Driver_Stm_Init();
    initShellInterface();
    print_enc(&now_status, &now_euler);
    initIMU();
    now13 = 1;

    in = 5;
    initGPIO();

    while (1)
    {
        AppScheduling();
        Touch();
    }
    return (1);
}

void AppTask1ms (void)
{
    stTestCnt.u32nuCnt1ms++;
}

void AppTask10ms (void)
{
    stTestCnt.u32nuCnt10ms++;

}

void AppTask100ms (void)
{
    stTestCnt.u32nuCnt100ms++;
    i++;
    //now13=2;
    //delay(5000); //0.005
    now_status = imuRead();
    //    float temp = now_status.mag_x;
    //    now_status.mag_x = now_status.mag_y;
    //    now_status.mag_y = temp;
    //    now_status.mag_x = -now_status.mag_x;

    //now13=3;
    //if (i > 400)
//    if(now_status.gyro_z>0.1 && now_status.gyro_z<-0.1 )
//    {
//
//    }
    if(stopstatus==1)
        {
            q0=1;
            q1=0;
            q2=0;
            q3=0;
        }
    now_euler = MadgwickAHRSupdateIMU(now_status);
    //now_euler = updateMadgwick(now_status);
    print_enc(&now_status, &now_euler);
    //if(i%100==0)checkoffset();

}

void AppTask1000ms (void)
{
    stTestCnt.u32nuCnt1000ms++;

}

void AppScheduling (void)
{
    if (stSchedulingInfo.u8nuScheduling1msFlag == 1u)
    {
        stSchedulingInfo.u8nuScheduling1msFlag = 0u;
        AppTask1ms();

        if (stSchedulingInfo.u8nuScheduling10msFlag == 1u)
        {
            stSchedulingInfo.u8nuScheduling10msFlag = 0u;
            AppTask10ms();
        }

        if (stSchedulingInfo.u8nuScheduling100msFlag == 1u)
        {
            stSchedulingInfo.u8nuScheduling100msFlag = 0u;
            AppTask100ms();
        }
        if (stSchedulingInfo.u8nuScheduling1000msFlag == 1u)
        {
            stSchedulingInfo.u8nuScheduling1000msFlag = 0u;
            AppTask1000ms();
        }
    }
}

void initGPIO(void)
{
    IfxPort_setPinMode(&MODULE_P14, 0, IfxPort_Mode_inputPullUp);//input으로 설정
}

void Touch(void)
{
    TouchState = IfxPort_getPinState(&MODULE_P14, 0);
    if(TouchState==1)
        stopstatus=1;
    else
        stopstatus=0;
}

