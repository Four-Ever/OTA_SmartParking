/**********************************************************************************************************************
 * \file OTA.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "OTA.h"
#include "OurCan.h"
#include "Flash_Programming.h"
#include "IfxFlash.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
FirmwareUpdateStat_t fwUpdateState = FW_UPDATE_IDLE;
volatile uint8 fwUpdateRequested = 0;
volatile uint8 fwUpdateComplete = 0;
uint32 fwUpdateAddress = 0;
uint32 fwUpdateSize = 0;
uint32 fwUpdateReceivedBytes = 0;

IfxMultican_Message messageBuffer[MESSAGE_BUFFER_SIZE];

volatile uint16 messageBufferHead = 0;
volatile uint16 messageBufferTail = 0;
uint32 currentUpdateAddr = 0;
uint8 temp = 0;
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
uint32 GetBootFlag(void) {
    return *(uint32*)BOOT_FLAG_ADDR;
}

void SetBootFlag(void){
    uint32 new_boot_flag;
    uint32 boot_flag = GetBootFlag();
    if (boot_flag == BOOT_FLAG_A)
        new_boot_flag = BOOT_FLAG_B;
    else
        new_boot_flag = BOOT_FLAG_A;

    uint16 password;

    // 1. 섹터 지우기
    password = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(password);
    IfxFlash_eraseMultipleSectors(BOOT_FLAG_ADDR, 1);  // 1개 섹터 지우기
    IfxScuWdt_setSafetyEndinit(password);

    // 지우기 완료 대기
    IfxFlash_waitUnbusy(0, IfxFlash_FlashType_D0);

    // 2. 데이터 쓰기
    // 페이지 모드 진입
    IfxFlash_enterPageMode(BOOT_FLAG_ADDR);
    IfxFlash_waitUnbusy(0, IfxFlash_FlashType_D0);

    // 데이터 로드 (8바이트 단위로 로드해야 함)
    IfxFlash_loadPage2X32(BOOT_FLAG_ADDR, new_boot_flag, 0);

    // 페이지 쓰기
    password = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(password);
    IfxFlash_writePage(BOOT_FLAG_ADDR);
    IfxScuWdt_setSafetyEndinit(password);

    // 쓰기 완료 대기
    IfxFlash_waitUnbusy(0, IfxFlash_FlashType_D0);
}

uint8 MessageBufferIsFull(void)
{
   return ((messageBufferHead + 1) % MESSAGE_BUFFER_SIZE) == messageBufferTail;
}

uint8 MessageBufferIsEmpty(void)
{
    return messageBufferHead == messageBufferTail;
}

void MessageBufferPut(IfxMultican_Message* msg)
{
    if (!MessageBufferIsFull())
    {
        messageBuffer[messageBufferHead] = *msg;
        messageBufferHead = (messageBufferHead + 1) % MESSAGE_BUFFER_SIZE;
    }
}

void MessageBufferGet(IfxMultican_Message* msg)
{
    if (!MessageBufferIsEmpty())
    {
        *msg = messageBuffer[messageBufferTail];
        messageBufferTail = (messageBufferTail + 1) % MESSAGE_BUFFER_SIZE;
    }
}

void StartFirmwareUpdate(void)
{
    uint32 boot_flag = GetBootFlag();
	if (boot_flag == BOOT_FLAG_A)
		fwUpdateAddress = APPLICATION_B_ADDRESS;
	else
		fwUpdateAddress = APPLICATION_A_ADDRESS;
	currentUpdateAddr = fwUpdateAddress;
    
    EraseProgramFlash(fwUpdateAddress);
}

void FirmwareUpdateStateMachine(void)
{
    switch (fwUpdateState)
    {
        case FW_UPDATE_IDLE:
            if (fwUpdateRequested)
            {
                StartFirmwareUpdate();
                fwUpdateState = FW_UPDATE_IN_PROGRESS;
            }
            break;

        case FW_UPDATE_IN_PROGRESS:
        {
           if (write_flag != 1 || fwUpdateSize == 0 || write_cnt == 0)
               return;
            
           boolean interruptState = IfxCpu_disableInterrupts();
           uint8 write_cnt_temp = write_cnt;
           if (write_cnt_temp > 4) {
               write_cnt_temp = 4;

           }
           write_cnt -= write_cnt_temp;
           IfxMultican_Message msg_arr[write_cnt_temp];
        

           for (int i = 0;i<write_cnt_temp;i++)
               MessageBufferGet((msg_arr+i));

//            if (temp == 0) {
//                temp++;
//                IfxCpu_restoreInterrupts(interruptState);
//                return;
//            }

            WriteFirmware(currentUpdateAddr,msg_arr,write_cnt_temp);

        
           
            currentUpdateAddr += 32;

           fwUpdateReceivedBytes += (8*write_cnt_temp);

           if (write_cnt <4)
               write_flag = 0;

           if (fwUpdateReceivedBytes == fwUpdateSize){
                  fwUpdateComplete = 1;
                  fwUpdateState = FW_UPDATE_COMPLETE;
           }
           IfxCpu_restoreInterrupts(interruptState);
           break;
        }
        case FW_UPDATE_COMPLETE:
        	SetBootFlag();
        	output_message(&db_msg.VCU_Camera, VCU_Camera_ID);
			//IfxCpu_triggerSwReset();
			__asm("ja (0x80000020)");
            break;

        default:
        	fwUpdateState = FW_UPDATE_IDLE;
            break;
    }
}
