/**********************************************************************************************************************
 * \file TC275_LCD_16x2.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
#include <stdio.h>
#include "TC275_LCD_16x2.h"
#include "IfxVadc.h"
#include "IfxVadc_Adc.h"
#include "Delay.h"
#include "IfxGtm_Tim.h"   // GTM 타이머 관련 라이브러리
//#include "Common_def.h"
#include "Controller_Logic.h"

/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/



/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
static const uint32 writeTimeConstant = 10;
static uint8 mode_8_4_I2C = 1;
static Ifx_P *PORT_RS_and_E;             // RS and E PORT
static uint8 PIN_RS, PIN_E;                  // RS and E pins
static Ifx_P *PORT_LSB;                  // LSBs D0, D1, D2 and D3 PORT
static uint8 D0_PIN, D1_PIN, D2_PIN, D3_PIN; // LSBs D0, D1, D2 and D3 pins
static Ifx_P *PORT_MSB;                  // MSBs D5, D6, D7 and D8 PORT
static Ifx_P *PORT_D4;
static uint8 D4_PIN, D5_PIN, D6_PIN, D7_PIN; // MSBs D5, D6, D7 and D8 pins


static uint8 DisplayControl = 0x0F;
static uint8 FunctionSet = 0x38;


//adc를 위한 변수


//디버깅을 위한 변수

/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/

/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/


// 1) Enable EN pulse
static void LCD1602_EnablePulse(void)
{
    IfxPort_setPinState(PORT_RS_and_E, PIN_E, IfxPort_State_high);
    MicroSecDelay(writeTimeConstant);
    IfxPort_setPinState(PORT_RS_and_E, PIN_E, IfxPort_State_low);
    MicroSecDelay(60);
}
// 2) RS control
static void LCD1602_RS(int state)
{
    if (state)
        IfxPort_setPinState(PORT_RS_and_E, PIN_RS, IfxPort_State_high);
    else
        IfxPort_setPinState(PORT_RS_and_E, PIN_RS, IfxPort_State_low);
}

// 3) Write Parallel interface
static void LCD1602_write(uint8 byte)
{
    uint8 LSB_nibble = byte & 0xF, MSB_nibble = (byte >> 4) & 0xF;

    if (mode_8_4_I2C == 1) // 8bits mode
    {
        // write data to output pins
        // LSB data
        IfxPort_setPinState(PORT_LSB, D0_PIN, (LSB_nibble & 0x1) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_LSB, D1_PIN, (LSB_nibble & 0x2) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_LSB, D2_PIN, (LSB_nibble & 0x4) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_LSB, D3_PIN, (LSB_nibble & 0x8) ? IfxPort_State_high : IfxPort_State_low);
        // MSB data
        IfxPort_setPinState(PORT_D4, D4_PIN, (MSB_nibble & 0x1) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D5_PIN, (MSB_nibble & 0x2) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D6_PIN, (MSB_nibble & 0x4) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D7_PIN, (MSB_nibble & 0x8) ? IfxPort_State_high : IfxPort_State_low);
        // Write the Enable pulse
        LCD1602_EnablePulse();
    }
    else if (mode_8_4_I2C == 2) // 4 bits mode
    {
        // write data to output pins
        // MSB data
        IfxPort_setPinState(PORT_D4, D4_PIN, (MSB_nibble & 0x1) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D5_PIN, (MSB_nibble & 0x2) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D6_PIN, (MSB_nibble & 0x4) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D7_PIN, (MSB_nibble & 0x8) ? IfxPort_State_high : IfxPort_State_low);
        // Write the Enable pulse
        LCD1602_EnablePulse();

        // LSB data
        IfxPort_setPinState(PORT_D4, D4_PIN, (LSB_nibble & 0x1) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D5_PIN, (LSB_nibble & 0x2) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D6_PIN, (LSB_nibble & 0x4) ? IfxPort_State_high : IfxPort_State_low);
        IfxPort_setPinState(PORT_MSB, D7_PIN, (LSB_nibble & 0x8) ? IfxPort_State_high : IfxPort_State_low);
        // Write the Enable pulse
        LCD1602_EnablePulse();
    }
}

// 5) Write command
static void LCD1602_writeCommand(uint8 command)
{
    // Set RS to 0
    LCD1602_RS(false);
    // Call low level write parallel function
    LCD1602_write(command);
}
// 6) Write 8 bits data
static void LCD1602_writeData(uint8 data)
{
    // Set RS to 1
    LCD1602_RS(true);
    // Call low level write parallel function
    LCD1602_write(data);
}
// 7) Write 4 bits command, *FOR 4 BITS MODE ONLY*
static void LCD1602_write4bitCommand(uint8 nibble)
{
    uint8 LSB_nibble = nibble & 0xF;
    // Set RS to 0
    LCD1602_RS(false);
    // LSB data D4,D5,D6,D7
    IfxPort_setPinState(PORT_D4, D4_PIN, (LSB_nibble & 0x1) ? IfxPort_State_high : IfxPort_State_low);
    IfxPort_setPinState(PORT_MSB, D5_PIN, (LSB_nibble & 0x2) ? IfxPort_State_high : IfxPort_State_low);
    IfxPort_setPinState(PORT_MSB, D6_PIN, (LSB_nibble & 0x4) ? IfxPort_State_high : IfxPort_State_low);
    IfxPort_setPinState(PORT_MSB, D7_PIN, (LSB_nibble & 0x8) ? IfxPort_State_high : IfxPort_State_low);
    // Write the Enable pulse
    LCD1602_EnablePulse();
}

// Public functions
// 1) LCD begin 8 bits function
void LCD1602_Begin8BIT(Ifx_P *PORT_RS_E, uint8 RS, uint8 E, Ifx_P *PORT_LSBs0to3, uint8 D0, uint8 D1, uint8 D2, uint8 D3, Ifx_P *PORT_MSBs4to7, uint8 D4, uint8 D5, uint8 D6, uint8 D7)
{
    // Set GPIO Ports and Pins data
    PORT_RS_and_E = PORT_RS_E;
    PIN_RS = RS;
    PIN_E = E;
    PORT_LSB = PORT_LSBs0to3;
    D0_PIN = D0;
    D1_PIN = D1;
    D2_PIN = D2;
    D3_PIN = D3;
    PORT_MSB = PORT_MSBs4to7;

    D4_PIN = D4;
    D5_PIN = D5;
    D6_PIN = D6;
    D7_PIN = D7;
    // Initialise microsecond timer
//    LCD1602_TIM_Config();
    // Set the mode to 8 bits
    mode_8_4_I2C = 1;
    // Function set variable to 8 bits mode
    FunctionSet = 0x38;

    // Initialise LCD
    // 1. Wait at least 15ms
    MilliSecDelay(20);
    // 2. Attentions sequence
    LCD1602_writeCommand(0x30);
    MilliSecDelay(5);
    LCD1602_writeCommand(0x30);
    MilliSecDelay(1);
    LCD1602_writeCommand(0x30);
    MilliSecDelay(1);
    // 3. Function set; Enable 2 lines, Data length to 8 bits
    LCD1602_writeCommand(LCD_FUNCTIONSET | LCD_FUNCTION_N | LCD_FUNCTION_DL);
    // 4. Display control (Display ON, Cursor ON, blink cursor)
    LCD1602_writeCommand(LCD_DISPLAYCONTROL | LCD_DISPLAY_B | LCD_DISPLAY_C | LCD_DISPLAY_D);
    // 5. Clear LCD and return home
    LCD1602_writeCommand(LCD_CLEARDISPLAY);
    MilliSecDelay(2);
}
// 2) LCD begin 4 bits function

/**
 * @brief  4BIT를 사용한 LED 초기 세팅 함수
 * @param  PORT_RS_E RS와 Enable 핀이 사용하는 Port
 * @param  RS RS핀 위치
 * @param  RS E핀 위치
 * @param  PORT_MSBs4to7 D4 ~ D7이 사용하는 Port
 * @param  D4 D4 핀 위치
 * @param  D5 D5 핀 위치
 * @param  D6 D6 핀 위치
 * @param  D7 D7 핀 위치
 * @note
 */
void LCD1602_Begin4BIT(Ifx_P *PORT_all, uint8 RS, uint8 E, Ifx_P *_PORT_D4, uint8 D4, uint8 D5, uint8 D6, uint8 D7)
{
    // Set GPIO Ports and Pins data
    PORT_RS_and_E = PORT_all;
    PIN_RS = RS;
    PIN_E = E;
    PORT_MSB = PORT_all;
    PORT_D4 = _PORT_D4;
    D4_PIN = D4;
    D5_PIN = D5;
    D6_PIN = D6;
    D7_PIN = D7;

    // Set the mode to 4 bits
    mode_8_4_I2C = 2;
    // Function set variable to 4 bits mode
    FunctionSet = 0x28;

    // Initialise LCD
    // 1. Wait at least 15ms
    MilliSecDelay(20);
    // 2. Attentions sequence
    LCD1602_write4bitCommand(0x3);
    MilliSecDelay(5);
    LCD1602_write4bitCommand(0x3);
    MilliSecDelay(1);
    LCD1602_write4bitCommand(0x3);
    MilliSecDelay(1);
    LCD1602_write4bitCommand(0x2); // 4 bit mode
    MilliSecDelay(1);
    // 3. Display control (Display ON, Cursor ON, blink cursor)
    LCD1602_writeCommand(LCD_DISPLAYCONTROL | LCD_DISPLAY_B | LCD_DISPLAY_C | LCD_DISPLAY_D);
    // 4. Clear LCD and return home
    LCD1602_writeCommand(LCD_CLEARDISPLAY);
    MilliSecDelay(3);
    // 4. Function set; Enable 2 lines, Data length to 8 bits
    LCD1602_writeCommand(LCD_FUNCTIONSET | LCD_FUNCTION_N);
    MilliSecDelay(3);
}
// 3) LCD print string
void LCD1602_print(char string[])
{
    for (uint8 i = 0; (i < 16 && string[i]); i++)
    {
        LCD1602_writeData((uint8)string[i]);
    }
}
// 4) set cursor position
void LCD1602_setCursor(uint8 row, uint8 col)
{
    uint8 maskData;
    maskData = (col - 1) & 0x0F;
    if (row == 1)
    {
        maskData |= (0x80);
        LCD1602_writeCommand(maskData);
    }
    else
    {
        maskData |= (0xc0);
        LCD1602_writeCommand(maskData);
    }
}
void LCD1602_1stLine(void)
{
    LCD1602_setCursor(1, 1);
}
void LCD1602_2ndLine(void)
{
    LCD1602_setCursor(2, 1);
}
// 5) Enable two lines
void LCD1602_TwoLines(void)
{
    FunctionSet |= (0x08);
    LCD1602_writeCommand(FunctionSet);
}
void LCD1602_OneLine(void)
{
    FunctionSet &= ~(0x08);
    LCD1602_writeCommand(FunctionSet);
}
// 6) Cursor ON/OFF
void LCD1602_noCursor(void)
{
    DisplayControl &= ~(0x02);
    LCD1602_writeCommand(DisplayControl);
}
void LCD1602_cursor(void)
{
    DisplayControl |= (0x02);
    LCD1602_writeCommand(DisplayControl);
}
// 7) Clear display
void LCD1602_clear(void)
{
    LCD1602_writeCommand(LCD_CLEARDISPLAY);
    MilliSecDelay(3);
}

// 8) Blinking cursor
void LCD1602_noBlink(void)
{
    DisplayControl &= ~(0x01);
    LCD1602_writeCommand(DisplayControl);
}
void LCD1602_blink(void)
{
    DisplayControl |= 0x01;
    LCD1602_writeCommand(DisplayControl);
}
// 9) Display ON/OFF
void LCD1602_noDisplay(void)
{
    DisplayControl &= ~(0x04);
    LCD1602_writeCommand(DisplayControl);
}
void LCD1602_display(void)
{
    DisplayControl |= (0x04);
    LCD1602_writeCommand(DisplayControl);
}
// 10) Shift Display, right or left
void LCD1602_shiftToRight(uint8 num)
{
    for (uint8 i = 0; i < num; i++)
    {
        LCD1602_writeCommand(0x1c);
    }
}
void LCD1602_shiftToLeft(uint8 num)
{
    for (uint8 i = 0; i < num; i++)
    {
        LCD1602_writeCommand(0x18);
    }
}

//********** Print numbers to LCD **********//
// 1. Integer
void LCD1602_PrintInt(int number)
{
    char numStr[16];
    sprintf(numStr, "%d", number);
    LCD1602_print(numStr);
}
// 2. Float
//void LCD1602_PrintFloat(float number, int decimalPoints)
//{
//  char numStr[16];
//  sprintf(numStr, "%.*f", decimalPoints, number);
//  LCD1602_print(numStr);
//}

// 3.캐릭터등록
void LCD1602_set_CGRAM(uint8 address, uint8 *data)
{
    LCD1602_writeCommand(0x40 | (address << 3)); // CGRAM 주소 설정
    for (int i = 0; i < 8; i++)
    {
        LCD1602_writeData(data[i]); // CGRAM에 데이터 쓰기
    }
}

void LCD1602_print_picture(Picture p)
{

    LCD1602_writeData(p);
}

void store_custom_img(){
    uint8 fullSquare[] = {
        0x1F,
        0x1F,
        0x1F,
        0x1F,
        0x1F,
        0x1F,
        0x1F,
        0x1F
    };
    LCD1602_set_CGRAM(0, fullSquare);
    uint8 down_arrow[] = {
        0x04,
        0x04,
        0x04,
        0x04,
        0x04,
        0x1F,
        0x0E,
        0x04
    };
    LCD1602_set_CGRAM(1, down_arrow);

    uint8 left_down_arrow[] = {
        0x01,
        0x03,
        0x12,
        0x14,
        0x14,
        0x1C,
        0x18,
        0x1F
    };
    LCD1602_set_CGRAM(2, left_down_arrow);

    uint8 rotated_line[] = {
        0x00,
        0x07,
        0x04,
        0x04,
        0x04,
        0x04,
        0x04,
        0x04
    };
    LCD1602_set_CGRAM(3, rotated_line);


}
void init_GPIO_LCD(){
    // P02 핀 설정 (OUTPUT)
    IfxPort_setPinModeOutput(&MODULE_P02, 6, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(&MODULE_P02, 7, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(&MODULE_P02, 3, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(&MODULE_P02, 4, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(&MODULE_P02, 5, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    // P10 핀 설정 (OUTPUT)
    IfxPort_setPinModeOutput(&MODULE_P10, 4, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    // 초기 상태 설정 (예: LOW)
    IfxPort_setPinLow(&MODULE_P02, 6);
    IfxPort_setPinLow(&MODULE_P02, 7);
    IfxPort_setPinLow(&MODULE_P02, 3);
    IfxPort_setPinLow(&MODULE_P02, 4);
    IfxPort_setPinLow(&MODULE_P02, 5);
    IfxPort_setPinLow(&MODULE_P10, 4);
}

void init_LCD()
{

    //  LCD1602_Begin4BIT(GPIOA, GPIO_PIN_8, GPIO_PIN_9, GPIOB, GPIO_PIN_3,
    //      GPIO_PIN_5, GPIO_PIN_4, GPIO_PIN_10);

    // FOR 103RB LCD!!!
    init_GPIO_LCD();


    LCD1602_Begin4BIT(&MODULE_P02, 6,7,&MODULE_P10, 4,3, 4, 5); // RS,E,D4,D5,D6,D7
    store_custom_img();

}



void LCD1602_print_percent_img(int val)
{

    int bars = (int)((val) / 9); // 100을 9로 나눈 값
    for (int i = 0; i < 11; i++)
    {

        if (i < bars)
        {
            LCD1602_print_picture(PIC_FULL_SQUARE); // 채워진 칸
        }
        else
        {
            LCD1602_print("_"); // 빈 칸
        }
    }

}
void LCD1602_loading(){ // 주행중일땐 사용 금지, 딜레이 발생
//    int dot = 0;
    for (int i = 0; i < 10; i++)
    {
        LCD1602_print("."); // 빈 칸
        MilliSecDelay(150);

    }
//    dot++;
}

void LCD1602_loading_nodelay(){
    int dot = (g_reset_timer / 4)%7 ;
    for (int i = 0; i < dot; i++)
    {
        LCD1602_print("."); // 빈 칸
//        MilliSecDelay(150);

    }

}

